// 카카오 프렌즈 컬러링 북
// https://programmers.co.kr/learn/courses/30/lessons/1829
#include <bits/stdc++.h>
using namespace std;

int dx[4] = { 0,0,-1,1 };
int dy[4] = { 1,-1,0,0 };

vector<int> solution(int m, int n, vector<vector<int>> picture) {
    vector <int> answer;
    bool visited[100][100] = {0,};
    int cnt = 0;
    int max_size = 0;
    queue <pair<int,int>> q;
    for(int i = 0; i < m; i++){
        for(int j = 0; j < n; j++){
            // 원소값이 0이 아니거나, 방문하지 않은 경우
            if(picture[i][j] != 0 && visited[i][j] == 0)  {
                q.push({i,j});
                visited[i][j] = 1;
                //cout << i << ' ' << j << ' ' << picture[j][i] << ' ';
                //cout << '\n';
                cnt++; // 갯수 증가
                int size = 0; // 가장 큰 크기 체크
                while(!q.empty()){
                    auto cur = q.front(); q.pop();
                    size++;
                    for(int dir = 0; dir < 4; dir++){
                        int nx = cur.first + dx[dir];
                        int ny = cur.second + dy[dir];
                        // 범위가 초과하면 큐에 넣지 않는다.
                        if(nx < 0 || nx >= m || ny < 0 || ny >= n)  continue;
                        // 동일한 값이 아니면 큐에 넣지 않는다.
                        if(picture[nx][ny] != picture[cur.first][cur.second]) continue;    
                        // 빈칸이거나 방문한 경우에는 큐에 넣지 않는다.
                        if(picture[nx][ny] == 0 || visited[nx][ny]) continue;
                        q.push({nx,ny});
                        visited[nx][ny] = 1;
                    }
                }
                max_size = max(max_size, size); // 가장 큰 크기를 가진 것을 찾는다.
            }
        }
    }
    answer.push_back(cnt);
    answer.push_back(max_size);
    return answer;
}